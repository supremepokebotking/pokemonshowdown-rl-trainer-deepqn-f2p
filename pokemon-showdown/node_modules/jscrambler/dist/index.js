'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('babel-polyfill');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _lodash = require('lodash.defaults');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _config2 = require('./config');

var _config3 = _interopRequireDefault(_config2);

var _generateSignedParams = require('./generate-signed-params');

var _generateSignedParams2 = _interopRequireDefault(_generateSignedParams);

var _client = require('./client');

var _client2 = _interopRequireDefault(_client);

var _mutations = require('./mutations');

var mutations = _interopRequireWildcard(_mutations);

var _queries = require('./queries');

var queries = _interopRequireWildcard(_queries);

var _constants = require('./constants');

var _zip = require('./zip');

var _introspection = require('./introspection');

var introspection = _interopRequireWildcard(_introspection);

var _utils = require('./utils');

var _getProtectionDefaultFragments = require('./get-protection-default-fragments');

var _getProtectionDefaultFragments2 = _interopRequireDefault(_getProtectionDefaultFragments);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* eslint-disable no-console */


var intoObjectType = introspection.intoObjectType;


var debug = !!process.env.DEBUG;
var APP_URL = 'https://app.jscrambler.com';
var POLLING_MIN_INTERVAL = 1000;
var POLLING_MAX_INTERVAL = 10000;
var INCREASE_POLL_INTERVAL_EVERY = 30000;

/**
 * Calculate polling interval for protection and instrumentation.
 * Upper limit of {POLLING_MAX_INTERVAL}.
 * @param start
 * @returns {number|number}
 */
function getPollingInterval(start) {
  var pollingInterval = POLLING_MIN_INTERVAL * Math.ceil((Date.now() - start) / INCREASE_POLL_INTERVAL_EVERY);
  return pollingInterval >= POLLING_MAX_INTERVAL ? POLLING_MAX_INTERVAL : pollingInterval;
}

function errorHandler(res) {
  if (res.errors && res.errors.length) {
    res.errors.forEach(function (error) {
      throw new Error('Error: ' + error.message);
    });
  }

  if (res.data && res.data.errors) {
    res.data.errors.forEach(function (e) {
      return console.error(e.message);
    });
    throw new Error('GraphQL Query Error');
  }

  if (res.message) {
    throw new Error('Error: ' + res.message);
  }

  return res;
}

function printSourcesErrors(errors) {
  console.error('Application sources errors:');
  console.error(JSON.stringify(errors, null, 2));
  console.error('');
}

function normalizeParameters(parameters) {
  var result = void 0;

  if (!Array.isArray(parameters)) {
    result = [];
    Object.keys(parameters).forEach(function (name) {
      result.push({
        name: name,
        options: parameters[name]
      });
    });
  } else {
    result = parameters;
  }

  return result;
}

function buildFinalConfig(configPathOrObject) {
  var _config = typeof configPathOrObject === 'string' ? require(configPathOrObject) : configPathOrObject;

  return (0, _lodash2.default)(_config, _config3.default);
}

exports.default = {
  Client: _client2.default,
  config: _config3.default,
  generateSignedParams: _generateSignedParams2.default,
  /**
   * Remove and Add application sources
   * @param {object} client
   * @param {string} applicationId
   * @param {{
   *  sources: Array.<{filename: string, content: string}>,
   *  filesSrc: Array.<string>,
   *  cwd: string,
   *  appProfiling: ?object
   * }} opts
   * @returns {Promise<{extension: string, filename: string, content: *}>}
   */
  updateApplicationSources: function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(client, applicationId, _ref) {
      var sources = _ref.sources,
          filesSrc = _ref.filesSrc,
          cwd = _ref.cwd,
          appProfiling = _ref.appProfiling;

      var removeSourceRes, zipped, source, _filesSrc, i, l, content;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(sources || filesSrc && filesSrc.length)) {
                _context.next = 7;
                break;
              }

              if (!(appProfiling && appProfiling.data && appProfiling.data.state === 'READY')) {
                _context.next = 3;
                break;
              }

              throw new Error('You have a finished Profiling for this application so you are NOT ALLOWED to update sources. To override this behavior use *--remove-profiling-data* or *--skip-sources*.');

            case 3:
              _context.next = 5;
              return this.removeSourceFromApplication(client, '', applicationId);

            case 5:
              removeSourceRes = _context.sent;


              errorHandler(removeSourceRes);

            case 7:
              zipped = void 0;
              source = void 0;

              if (!(filesSrc && filesSrc.length)) {
                _context.next = 18;
                break;
              }

              _filesSrc = [];

              for (i = 0, l = filesSrc.length; i < l; i += 1) {
                if (typeof filesSrc[i] === 'string') {
                  _filesSrc = _filesSrc.concat((0, _utils.getMatchedFiles)(filesSrc[i]));
                } else {
                  _filesSrc.push(filesSrc[i]);
                }
              }

              if (debug) {
                console.log('Creating zip from source files');
              }

              _context.next = 15;
              return (0, _zip.zip)(_filesSrc, cwd);

            case 15:
              zipped = _context.sent;
              _context.next = 23;
              break;

            case 18:
              if (!sources) {
                _context.next = 23;
                break;
              }

              if (debug) {
                console.log('Creating zip from sources');
              }

              _context.next = 22;
              return (0, _zip.zipSources)(sources);

            case 22:
              zipped = _context.sent;

            case 23:
              if (!zipped) {
                _context.next = 34;
                break;
              }

              _context.next = 26;
              return zipped.generateAsync({
                type: 'base64'
              });

            case 26:
              content = _context.sent;


              if (debug) {
                console.log('Adding sources to application');
              }

              source = {
                content: content,
                filename: 'application.zip',
                extension: 'zip'
              };

              _context.t0 = errorHandler;
              _context.next = 32;
              return this.addApplicationSource(client, applicationId, source);

            case 32:
              _context.t1 = _context.sent;
              (0, _context.t0)(_context.t1);

            case 34:
              return _context.abrupt('return', source);

            case 35:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function updateApplicationSources(_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    }

    return updateApplicationSources;
  }(),

  // This method is a shortcut method that accepts an object with everything needed
  // for the entire process of requesting an application protection and downloading
  // that same protection when the same ends.
  //
  // `configPathOrObject` can be a path to a JSON or directly an object containing
  // the following structure:
  //
  // ```json
  // {
  //   "keys": {
  //     "accessKey": "",
  //     "secretKey": ""
  //   },
  //   "applicationId": "",
  //   "filesDest": ""
  // }
  // ```
  //
  // Also the following optional parameters are accepted:
  //
  // ```json
  // {
  //   "filesSrc": [""],
  //   "params": {},
  //   "cwd": "",
  //   "host": "api.jscrambler.com",
  //   "port": "443",
  //   "basePath": ""
  // }
  // ```
  //
  // `filesSrc` supports glob patterns, and if it's provided it will replace the
  // entire application sources.
  //
  // `params` if provided will replace all the application transformation parameters.
  //
  // `cwd` allows you to set the current working directory to resolve problems with
  // relative paths with your `filesSrc` is outside the current working directory.
  //
  // Finally, `host` and `port` can be overridden if you to engage with a different
  // endpoint than the default one, useful if you're running an enterprise version of
  // Jscrambler or if you're provided access to beta features of our product.
  //
  protectAndDownload: function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(configPathOrObject, destCallback) {
      var _this = this;

      var finalConfig, applicationId, host, port, basePath, protocol, cafile, keys, sources, _finalConfig$stream, stream, cwd, params, applicationTypes, languageSpecifications, sourceMaps, randomizationSeed, areSubscribersOrdered, useRecommendedOrder, _finalConfig$bail, bail, jscramblerVersion, debugMode, proxy, utc, clientId, tolerateMinification, codeHardeningThreshold, useProfilingData, browsers, useAppClassification, profilingDataMode, removeProfilingData, skipSources, inputSymbolTable, entryPoint, excludeList, forceAppEnvironment, accessKey, secretKey, client, filesSrc, filesDest, source, appProfiling, updateData, dataToValidate, prop, value, applicationUpdate, updateApplicationRes, protectionOptions, inputSymbolTableContents, createApplicationProtectionRes, protectionId, onExitCancelProtection, protection, sourcesErrors, download;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              finalConfig = buildFinalConfig(configPathOrObject);
              applicationId = finalConfig.applicationId, host = finalConfig.host, port = finalConfig.port, basePath = finalConfig.basePath, protocol = finalConfig.protocol, cafile = finalConfig.cafile, keys = finalConfig.keys, sources = finalConfig.sources, _finalConfig$stream = finalConfig.stream, stream = _finalConfig$stream === undefined ? true : _finalConfig$stream, cwd = finalConfig.cwd, params = finalConfig.params, applicationTypes = finalConfig.applicationTypes, languageSpecifications = finalConfig.languageSpecifications, sourceMaps = finalConfig.sourceMaps, randomizationSeed = finalConfig.randomizationSeed, areSubscribersOrdered = finalConfig.areSubscribersOrdered, useRecommendedOrder = finalConfig.useRecommendedOrder, _finalConfig$bail = finalConfig.bail, bail = _finalConfig$bail === undefined ? true : _finalConfig$bail, jscramblerVersion = finalConfig.jscramblerVersion, debugMode = finalConfig.debugMode, proxy = finalConfig.proxy, utc = finalConfig.utc, clientId = finalConfig.clientId, tolerateMinification = finalConfig.tolerateMinification, codeHardeningThreshold = finalConfig.codeHardeningThreshold, useProfilingData = finalConfig.useProfilingData, browsers = finalConfig.browsers, useAppClassification = finalConfig.useAppClassification, profilingDataMode = finalConfig.profilingDataMode, removeProfilingData = finalConfig.removeProfilingData, skipSources = finalConfig.skipSources, inputSymbolTable = finalConfig.inputSymbolTable, entryPoint = finalConfig.entryPoint, excludeList = finalConfig.excludeList, forceAppEnvironment = finalConfig.forceAppEnvironment;
              accessKey = keys.accessKey, secretKey = keys.secretKey;
              client = new this.Client({
                accessKey: accessKey,
                secretKey: secretKey,
                host: host,
                port: port,
                basePath: basePath,
                protocol: protocol,
                cafile: cafile,
                jscramblerVersion: jscramblerVersion,
                proxy: proxy,
                utc: utc,
                clientId: clientId
              });
              filesSrc = finalConfig.filesSrc;
              filesDest = finalConfig.filesDest;


              if (sources) {
                filesSrc = undefined;
              }

              if (destCallback) {
                filesDest = undefined;
              }

              if (applicationId) {
                _context2.next = 10;
                break;
              }

              throw new Error('Required *applicationId* not provided');

            case 10:
              if (!(!filesDest && !destCallback)) {
                _context2.next = 12;
                break;
              }

              throw new Error('Required *filesDest* not provided');

            case 12:
              source = void 0;

              if (skipSources) {
                _context2.next = 26;
                break;
              }

              _context2.next = 16;
              return this.getApplicationProfiling(client, applicationId).catch(function (e) {
                if (![_constants.HTTP_STATUS_CODES.NOT_FOUND, _constants.HTTP_STATUS_CODES.FORBIDDEN, _constants.HTTP_STATUS_CODES.SERVICE_UNAVAILABLE].includes(e.statusCode)) throw e;
              });

            case 16:
              appProfiling = _context2.sent;

              if (!(appProfiling && removeProfilingData)) {
                _context2.next = 21;
                break;
              }

              _context2.next = 20;
              return this.deleteProfiling(client, appProfiling.data.id);

            case 20:
              appProfiling.data.state = 'DELETED';

            case 21:
              _context2.next = 23;
              return this.updateApplicationSources(client, applicationId, {
                sources: sources,
                filesSrc: filesSrc,
                cwd: cwd,
                appProfiling: appProfiling
              });

            case 23:
              source = _context2.sent;
              _context2.next = 27;
              break;

            case 26:
              console.log('Update source files SKIPPED');

            case 27:
              updateData = {
                _id: applicationId,
                debugMode: !!debugMode,
                tolerateMinification: tolerateMinification,
                codeHardeningThreshold: codeHardeningThreshold
              };


              if (params && Object.keys(params).length) {
                updateData.parameters = normalizeParameters(params);
                updateData.areSubscribersOrdered = Array.isArray(params);
              }

              dataToValidate = {
                applicationTypes: applicationTypes,
                areSubscribersOrdered: areSubscribersOrdered,
                browsers: browsers,
                languageSpecifications: languageSpecifications,
                profilingDataMode: profilingDataMode,
                sourceMaps: sourceMaps,
                useAppClassification: useAppClassification,
                useProfilingData: useProfilingData,
                useRecommendedOrder: useRecommendedOrder
              };


              for (prop in dataToValidate) {
                value = dataToValidate[prop];

                if (typeof value !== 'undefined') {
                  updateData[prop] = value;
                }
              }

              if (!(updateData.parameters || updateData.applicationTypes || updateData.languageSpecifications || updateData.browsers || typeof updateData.areSubscribersOrdered !== 'undefined')) {
                _context2.next = 41;
                break;
              }

              if (debug) {
                console.log('Updating parameters of protection');
              }

              _context2.next = 35;
              return intoObjectType(client, updateData, 'Application');

            case 35:
              applicationUpdate = _context2.sent;
              _context2.next = 38;
              return this.updateApplication(client, applicationUpdate);

            case 38:
              updateApplicationRes = _context2.sent;

              if (debug) {
                console.log('Finished updating parameters of protection');
                console.error(updateApplicationRes);
              }
              errorHandler(updateApplicationRes);

            case 41:

              if (debug) {
                console.log('Creating Application Protection');
              }

              delete updateData._id;
              protectionOptions = Object.assign({}, updateData, {
                bail: bail,
                entryPoint: entryPoint,
                excludeList: excludeList,
                inputSymbolTable: inputSymbolTable,
                randomizationSeed: randomizationSeed,
                source: source,
                tolerateMinification: tolerateMinification,
                forceAppEnvironment: forceAppEnvironment
              });


              if (finalConfig.inputSymbolTable) {
                // Note: we can not use the fs.promises API because some users may not have node 10.
                // Once node 10 is old enough to be safe to assume that all users will have it, this
                // should be safe to replace with `await fs.promises.readFile`.
                inputSymbolTableContents = _fs2.default.readFileSync(finalConfig.inputSymbolTable, 'utf-8');

                protectionOptions.inputSymbolTable = inputSymbolTableContents;
              }

              _context2.next = 47;
              return this.createApplicationProtection(client, applicationId, protectionOptions);

            case 47:
              createApplicationProtectionRes = _context2.sent;

              errorHandler(createApplicationProtectionRes);

              protectionId = createApplicationProtectionRes.data.createApplicationProtection._id;

              onExitCancelProtection = function onExitCancelProtection() {
                _this.cancelProtection(client, protectionId, applicationId).then(function () {
                  return console.log('\n** Protection %s WAS CANCELLED **', protectionId);
                }).catch(function () {
                  return debug && console.error(e);
                }).finally(function () {
                  return process.exit(1);
                });
              };

              process.once('SIGINT', onExitCancelProtection).once('SIGTERM', onExitCancelProtection);

              _context2.t0 = this;
              _context2.t1 = client;
              _context2.t2 = applicationId;
              _context2.t3 = protectionId;
              _context2.next = 58;
              return (0, _getProtectionDefaultFragments2.default)(client);

            case 58:
              _context2.t4 = _context2.sent;
              _context2.next = 61;
              return _context2.t0.pollProtection.call(_context2.t0, _context2.t1, _context2.t2, _context2.t3, _context2.t4);

            case 61:
              protection = _context2.sent;


              process.removeListener('SIGINT', onExitCancelProtection).removeListener('SIGTERM', onExitCancelProtection);

              if (protection.growthWarning) {
                console.warn('Warning: Your protected application has surpassed a reasonable file growth.\nFor more information on what might have caused this, please see the Protection Report.\nLink: ' + APP_URL + '.');
              }
              if (debug) {
                console.log('Finished protecting');
              }

              if (protection.deprecations) {
                protection.deprecations.forEach(function (deprecation) {
                  if (deprecation.type === 'Transformation') {
                    console.warn('Warning: ' + deprecation.type + ' ' + deprecation.entity + ' is no longer maintained. Please consider removing it from your configuration.');
                  } else if (deprecation.type && deprecation.entity) {
                    console.warn('Warning: ' + deprecation.type + ' ' + deprecation.entity + ' is deprecated.');
                  }
                });
              }

              sourcesErrors = [];


              protection.sources.forEach(function (s) {
                if (s.errorMessages && s.errorMessages.length > 0) {
                  sourcesErrors.push.apply(sourcesErrors, _toConsumableArray(s.errorMessages.map(function (e) {
                    return Object.assign({
                      filename: s.filename
                    }, e);
                  })));
                }
              });

              if (!(protection.state === 'errored')) {
                _context2.next = 76;
                break;
              }

              console.error('Global protection errors:');
              console.error('- ' + protection.errorMessage);
              console.error('');
              if (sourcesErrors.length > 0) {
                printSourcesErrors(sourcesErrors);
              }
              throw new Error('Protection failed. For more information visit: ' + APP_URL + '.');

            case 76:
              if (!(sourcesErrors.length > 0)) {
                _context2.next = 83;
                break;
              }

              if (!protection.bail) {
                _context2.next = 82;
                break;
              }

              printSourcesErrors(sourcesErrors);
              throw new Error('Your protection has failed.');

            case 82:
              sourcesErrors.forEach(function (e) {
                return console.warn('Non-fatal error: "' + e.message + '" in ' + e.filename);
              });

            case 83:

              if (debug) {
                console.log('Downloading protection result');
              }
              _context2.next = 86;
              return this.downloadApplicationProtection(client, protectionId);

            case 86:
              download = _context2.sent;


              errorHandler(download);

              if (debug) {
                console.log('Unzipping files');
              }

              _context2.next = 91;
              return (0, _zip.unzip)(download, filesDest || destCallback, stream);

            case 91:

              if (debug) {
                console.log('Finished unzipping files');
              }

              console.log(protectionId);

              return _context2.abrupt('return', protectionId);

            case 94:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function protectAndDownload(_x4, _x5) {
      return _ref3.apply(this, arguments);
    }

    return protectAndDownload;
  }(),

  /**
   * Instrument and download application sources for profiling purposes
   * @param {object} configPathOrObject
   * @param {function} [destCallback]
   * @returns {Promise<string>}
   */
  instrumentAndDownload: function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(configPathOrObject, destCallback) {
      var _this2 = this;

      var finalConfig, applicationId, host, port, basePath, protocol, cafile, keys, sources, _finalConfig$stream2, stream, cwd, jscramblerVersion, proxy, utc, skipSources, clientId, accessKey, secretKey, client, filesSrc, filesDest, instrumentation, onExitCancelInstrumentation, download;

      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              finalConfig = buildFinalConfig(configPathOrObject);
              applicationId = finalConfig.applicationId, host = finalConfig.host, port = finalConfig.port, basePath = finalConfig.basePath, protocol = finalConfig.protocol, cafile = finalConfig.cafile, keys = finalConfig.keys, sources = finalConfig.sources, _finalConfig$stream2 = finalConfig.stream, stream = _finalConfig$stream2 === undefined ? true : _finalConfig$stream2, cwd = finalConfig.cwd, jscramblerVersion = finalConfig.jscramblerVersion, proxy = finalConfig.proxy, utc = finalConfig.utc, skipSources = finalConfig.skipSources, clientId = finalConfig.clientId;
              accessKey = keys.accessKey, secretKey = keys.secretKey;
              client = new this.Client({
                accessKey: accessKey,
                secretKey: secretKey,
                host: host,
                port: port,
                basePath: basePath,
                protocol: protocol,
                cafile: cafile,
                jscramblerVersion: jscramblerVersion,
                proxy: proxy,
                utc: utc,
                clientId: clientId
              });
              filesSrc = finalConfig.filesSrc, filesDest = finalConfig.filesDest;


              if (sources) {
                filesSrc = undefined;
              }

              if (destCallback) {
                filesDest = undefined;
              }

              if (applicationId) {
                _context3.next = 9;
                break;
              }

              throw new Error('Required *applicationId* not provided');

            case 9:
              if (!(!filesDest && !destCallback)) {
                _context3.next = 11;
                break;
              }

              throw new Error('Required *filesDest* not provided');

            case 11:
              if (skipSources) {
                _context3.next = 16;
                break;
              }

              _context3.next = 14;
              return this.updateApplicationSources(client, applicationId, {
                sources: sources,
                filesSrc: filesSrc,
                cwd: cwd
              });

            case 14:
              _context3.next = 17;
              break;

            case 16:
              console.log('Update source files SKIPPED');

            case 17:
              _context3.next = 19;
              return this.startInstrumentation(client, applicationId);

            case 19:
              instrumentation = _context3.sent;

              errorHandler(instrumentation);

              onExitCancelInstrumentation = function onExitCancelInstrumentation() {
                _this2.deleteProfiling(client, instrumentation.data.id).then(function () {
                  return console.log('\n** Instrumentation %s WAS CANCELLED **', instrumentation.data.id);
                }).catch(function () {
                  return debug && console.error(e);
                }).finally(function () {
                  return process.exit(1);
                });
              };

              process.once('SIGINT', onExitCancelInstrumentation).once('SIGTERM', onExitCancelInstrumentation);

              _context3.next = 25;
              return this.pollInstrumentation(client, instrumentation.data.id);

            case 25:
              instrumentation = _context3.sent;


              process.removeListener('SIGINT', onExitCancelInstrumentation).removeListener('SIGTERM', onExitCancelInstrumentation);

              if (debug) {
                console.log('Finished instrumention with id ' + instrumentation.data.id + '. Downloading...');
              }

              _context3.next = 30;
              return this.downloadApplicationInstrumented(client, instrumentation.data.id);

            case 30:
              download = _context3.sent;

              errorHandler(download);

              if (debug) {
                console.log('Unzipping files');
              }

              _context3.next = 35;
              return (0, _zip.unzip)(download, filesDest || destCallback, stream);

            case 35:

              if (debug) {
                console.log('Finished unzipping files');
              }

              console.warn('\n      WARNING: DO NOT SEND THIS CODE TO PRODUCTION AS IT IS NOT PROTECTED\n    ');

              console.log('Application ' + applicationId + ' was instrumented. Bootstrap your instrumented application and run *--start-profiling* command.');

              return _context3.abrupt('return', instrumentation.data.id);

            case 39:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function instrumentAndDownload(_x6, _x7) {
      return _ref4.apply(this, arguments);
    }

    return instrumentAndDownload;
  }(),


  /**
   * Change the profiling run stat.
   * @param configPathOrObject
   * @param state
   * @param label
   * @param {string} nextStepMessage
   * @returns {Promise<string>} The previous state
   */
  setProfilingState: function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(configPathOrObject, state, label, nextStepMessage) {
      var finalConfig, keys, host, port, basePath, protocol, cafile, applicationId, proxy, utc, jscramblerVersion, clientId, accessKey, secretKey, client, instrumentation, previousState;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              finalConfig = buildFinalConfig(configPathOrObject);
              keys = finalConfig.keys, host = finalConfig.host, port = finalConfig.port, basePath = finalConfig.basePath, protocol = finalConfig.protocol, cafile = finalConfig.cafile, applicationId = finalConfig.applicationId, proxy = finalConfig.proxy, utc = finalConfig.utc, jscramblerVersion = finalConfig.jscramblerVersion, clientId = finalConfig.clientId;
              accessKey = keys.accessKey, secretKey = keys.secretKey;
              client = new this.Client({
                accessKey: accessKey,
                secretKey: secretKey,
                host: host,
                port: port,
                basePath: basePath,
                protocol: protocol,
                cafile: cafile,
                proxy: proxy,
                utc: utc,
                jscramblerVersion: jscramblerVersion,
                clientId: clientId
              });
              _context4.next = 6;
              return client.get('/profiling-run', { applicationId: applicationId }).catch(function (e) {
                if (e.statusCode !== 404) throw e;
              });

            case 6:
              instrumentation = _context4.sent;

              if (instrumentation) {
                _context4.next = 9;
                break;
              }

              throw new Error('There is no active profiling run. Instrument your application first.');

            case 9:
              previousState = instrumentation.data.state;

              if (!(previousState === state)) {
                _context4.next = 13;
                break;
              }

              console.log('Profiling was already ' + label + ' for application ' + applicationId + '. ' + nextStepMessage);
              return _context4.abrupt('return');

            case 13:
              _context4.next = 15;
              return client.patch('/profiling-run/' + instrumentation.data.id, {
                state: state
              });

            case 15:

              console.log('Profiling was ' + label + ' for application ' + applicationId + '. ' + nextStepMessage);

            case 16:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function setProfilingState(_x8, _x9, _x10, _x11) {
      return _ref5.apply(this, arguments);
    }

    return setProfilingState;
  }(),
  downloadSourceMaps: function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(configs, destCallback) {
      var keys, host, port, basePath, protocol, cafile, _configs$stream, stream, filesDest, filesSrc, protectionId, jscramblerVersion, utc, proxy, accessKey, secretKey, client, download;

      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              keys = configs.keys, host = configs.host, port = configs.port, basePath = configs.basePath, protocol = configs.protocol, cafile = configs.cafile, _configs$stream = configs.stream, stream = _configs$stream === undefined ? true : _configs$stream, filesDest = configs.filesDest, filesSrc = configs.filesSrc, protectionId = configs.protectionId, jscramblerVersion = configs.jscramblerVersion, utc = configs.utc, proxy = configs.proxy;
              accessKey = keys.accessKey, secretKey = keys.secretKey;
              client = new this.Client({
                accessKey: accessKey,
                secretKey: secretKey,
                host: host,
                port: port,
                basePath: basePath,
                protocol: protocol,
                cafile: cafile,
                jscramblerVersion: jscramblerVersion,
                utc: utc,
                proxy: proxy
              });

              if (!(!filesDest && !destCallback)) {
                _context5.next = 5;
                break;
              }

              throw new Error('Required *filesDest* not provided');

            case 5:
              if (protectionId) {
                _context5.next = 7;
                break;
              }

              throw new Error('Required *protectionId* not provided');

            case 7:

              if (filesSrc) {
                console.warn('[Warning] Ignoring sources supplied. Downloading source maps of given protection');
              }
              download = void 0;
              _context5.prev = 9;
              _context5.next = 12;
              return this.downloadSourceMapsRequest(client, protectionId);

            case 12:
              download = _context5.sent;
              _context5.next = 18;
              break;

            case 15:
              _context5.prev = 15;
              _context5.t0 = _context5['catch'](9);

              errorHandler(_context5.t0);

            case 18:
              _context5.next = 20;
              return (0, _zip.unzip)(download, filesDest || destCallback, stream);

            case 20:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, this, [[9, 15]]);
    }));

    function downloadSourceMaps(_x12, _x13) {
      return _ref6.apply(this, arguments);
    }

    return downloadSourceMaps;
  }(),
  downloadSymbolTable: function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(configs, destCallback) {
      var keys, host, port, basePath, protocol, cafile, _configs$stream2, stream, filesDest, filesSrc, protectionId, jscramblerVersion, utc, proxy, accessKey, secretKey, client, download;

      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              keys = configs.keys, host = configs.host, port = configs.port, basePath = configs.basePath, protocol = configs.protocol, cafile = configs.cafile, _configs$stream2 = configs.stream, stream = _configs$stream2 === undefined ? true : _configs$stream2, filesDest = configs.filesDest, filesSrc = configs.filesSrc, protectionId = configs.protectionId, jscramblerVersion = configs.jscramblerVersion, utc = configs.utc, proxy = configs.proxy;
              accessKey = keys.accessKey, secretKey = keys.secretKey;
              client = new this.Client({
                accessKey: accessKey,
                secretKey: secretKey,
                host: host,
                port: port,
                basePath: basePath,
                protocol: protocol,
                cafile: cafile,
                jscramblerVersion: jscramblerVersion,
                utc: utc,
                proxy: proxy
              });

              if (!(!filesDest && !destCallback)) {
                _context6.next = 5;
                break;
              }

              throw new Error('Required *filesDest* not provided');

            case 5:
              if (protectionId) {
                _context6.next = 7;
                break;
              }

              throw new Error('Required *protectionId* not provided');

            case 7:

              if (filesSrc) {
                console.warn('[Warning] Ignoring sources supplied. Downloading symbol table of given protection');
              }
              download = void 0;
              _context6.prev = 9;
              _context6.next = 12;
              return this.downloadSymbolTableRequest(client, protectionId);

            case 12:
              download = _context6.sent;
              _context6.next = 18;
              break;

            case 15:
              _context6.prev = 15;
              _context6.t0 = _context6['catch'](9);

              errorHandler(_context6.t0);

            case 18:

              if (typeof destCallback === 'function') {
                destCallback(download, filesDest);
              } else {
                (0, _zip.outputFileSync)(_path2.default.join(filesDest, protectionId + '_symbolTable.json'), download);
              }

            case 19:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, this, [[9, 15]]);
    }));

    function downloadSymbolTable(_x14, _x15) {
      return _ref7.apply(this, arguments);
    }

    return downloadSymbolTable;
  }(),

  /**
   * Polls a instrumentation every POLLING_INTERVALms until the state be equal to
   * FINISHED_INSTRUMENTATION, FAILED_INSTRUMENTATION or DELETED
   * @param {object} client
   * @param {string} instrumentationId
   * @returns {Promise<object>}
   * @throws {Error} due to errors in instrumentation process or user cancel the operation
   */
  pollInstrumentation: function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(client, instrumentationId) {
      var _this3 = this;

      var start, poll;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              start = Date.now();

              poll = function () {
                var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                  var instrumentation;
                  return regeneratorRuntime.wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          _context7.next = 2;
                          return _this3.getInstrumentation(client, instrumentationId);

                        case 2:
                          instrumentation = _context7.sent;
                          _context7.t0 = instrumentation.data.state;
                          _context7.next = _context7.t0 === 'DELETED' ? 6 : _context7.t0 === 'FAILED_INSTRUMENTATION' ? 7 : _context7.t0 === 'FINISHED_INSTRUMENTATION' ? 9 : 10;
                          break;

                        case 6:
                          throw new Error('Protection canceled by user');

                        case 7:
                          instrumentation.errors = instrumentation.errors.concat(instrumentation.data.instrumentationErrors.map(function (e) {
                            return {
                              message: e.message + ' at ' + e.fileName + ':' + e.lineNumber
                            };
                          }));
                          return _context7.abrupt('return', errorHandler(instrumentation));

                        case 9:
                          return _context7.abrupt('return', instrumentation);

                        case 10:
                          _context7.next = 12;
                          return new Promise(function (resolve) {
                            return setTimeout(resolve, getPollingInterval(start));
                          });

                        case 12:
                          return _context7.abrupt('return', poll());

                        case 13:
                        case 'end':
                          return _context7.stop();
                      }
                    }
                  }, _callee7, _this3);
                }));

                return function poll() {
                  return _ref9.apply(this, arguments);
                };
              }();

              return _context8.abrupt('return', poll());

            case 3:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function pollInstrumentation(_x16, _x17) {
      return _ref8.apply(this, arguments);
    }

    return pollInstrumentation;
  }(),
  withRetries: function () {
    var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(action) {
      var retriesLeft;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              retriesLeft = _config3.default.maxRetries;

            case 1:
              _context9.prev = 1;
              _context9.next = 4;
              return action();

            case 4:
              return _context9.abrupt('return', _context9.sent);

            case 7:
              _context9.prev = 7;
              _context9.t0 = _context9['catch'](1);

              if (!(retriesLeft <= 0)) {
                _context9.next = 11;
                break;
              }

              throw _context9.t0;

            case 11:
              if (!(_context9.t0.statusCode !== _constants.HTTP_STATUS_CODES.SERVICE_UNAVAILABLE && _context9.t0.statusCode !== _constants.HTTP_STATUS_CODES.GATEWAY_TIMEOUT)) {
                _context9.next = 13;
                break;
              }

              throw _context9.t0;

            case 13:
              // Retry
              if (debug) {
                console.log('Retrying request');
              }
              retriesLeft--;

            case 15:
              _context9.next = 1;
              break;

            case 17:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, this, [[1, 7]]);
    }));

    function withRetries(_x18) {
      return _ref10.apply(this, arguments);
    }

    return withRetries;
  }(),
  pollProtection: function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(client, applicationId, protectionId, fragments) {
      var _this4 = this;

      var start, poll;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              start = Date.now();

              poll = function () {
                var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
                  var applicationProtection, state;
                  return regeneratorRuntime.wrap(function _callee10$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          _context10.next = 2;
                          return _this4.withRetries(function () {
                            return _this4.getApplicationProtection(client, applicationId, protectionId, fragments);
                          });

                        case 2:
                          applicationProtection = _context10.sent;

                          if (!applicationProtection.errors) {
                            _context10.next = 8;
                            break;
                          }

                          console.log('Error polling protection', applicationProtection.errors);

                          throw new Error('Protection failed. For more information visit: ' + APP_URL + '.');

                        case 8:
                          state = applicationProtection.data.applicationProtection.state;

                          if (!(state !== 'finished' && state !== 'errored' && state !== 'canceled')) {
                            _context10.next = 15;
                            break;
                          }

                          _context10.next = 12;
                          return new Promise(function (resolve) {
                            return setTimeout(resolve, getPollingInterval(start));
                          });

                        case 12:
                          return _context10.abrupt('return', poll());

                        case 15:
                          if (!(state === 'canceled')) {
                            _context10.next = 19;
                            break;
                          }

                          throw new Error('Protection canceled by user');

                        case 19:
                          return _context10.abrupt('return', applicationProtection.data.applicationProtection);

                        case 20:
                        case 'end':
                          return _context10.stop();
                      }
                    }
                  }, _callee10, _this4);
                }));

                return function poll() {
                  return _ref12.apply(this, arguments);
                };
              }();

              return _context11.abrupt('return', poll());

            case 3:
            case 'end':
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function pollProtection(_x19, _x20, _x21, _x22) {
      return _ref11.apply(this, arguments);
    }

    return pollProtection;
  }(),

  //
  createApplication: function () {
    var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(client, data, fragments) {
      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.abrupt('return', client.post('/application', mutations.createApplication(data, fragments)));

            case 1:
            case 'end':
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function createApplication(_x23, _x24, _x25) {
      return _ref13.apply(this, arguments);
    }

    return createApplication;
  }(),

  //
  duplicateApplication: function () {
    var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(client, data, fragments) {
      return regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.abrupt('return', client.post('/application', mutations.duplicateApplication(data, fragments)));

            case 1:
            case 'end':
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function duplicateApplication(_x26, _x27, _x28) {
      return _ref14.apply(this, arguments);
    }

    return duplicateApplication;
  }(),

  //
  removeApplication: function () {
    var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(client, id) {
      return regeneratorRuntime.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.abrupt('return', client.post('/application', mutations.removeApplication(id)));

            case 1:
            case 'end':
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function removeApplication(_x29, _x30) {
      return _ref15.apply(this, arguments);
    }

    return removeApplication;
  }(),

  //
  removeProtection: function () {
    var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(client, id, appId, fragments) {
      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              return _context15.abrupt('return', client.post('/application', mutations.removeProtection(id, appId, fragments)));

            case 1:
            case 'end':
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function removeProtection(_x31, _x32, _x33, _x34) {
      return _ref16.apply(this, arguments);
    }

    return removeProtection;
  }(),

  //
  cancelProtection: function () {
    var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(client, id, appId, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return mutations.cancelProtection(id, appId, fragments);

            case 2:
              mutation = _context16.sent;
              return _context16.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function cancelProtection(_x35, _x36, _x37, _x38) {
      return _ref17.apply(this, arguments);
    }

    return cancelProtection;
  }(),

  //
  updateApplication: function () {
    var _ref18 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(client, application, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return mutations.updateApplication(application, fragments);

            case 2:
              mutation = _context17.sent;
              return _context17.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function updateApplication(_x39, _x40, _x41) {
      return _ref18.apply(this, arguments);
    }

    return updateApplication;
  }(),

  //
  unlockApplication: function () {
    var _ref19 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(client, application, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return mutations.unlockApplication(application, fragments);

            case 2:
              mutation = _context18.sent;
              return _context18.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function unlockApplication(_x42, _x43, _x44) {
      return _ref19.apply(this, arguments);
    }

    return unlockApplication;
  }(),

  //
  getApplication: function () {
    var _ref20 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(client, applicationId, fragments, params) {
      var query;
      return regeneratorRuntime.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return queries.getApplication(applicationId, fragments, params);

            case 2:
              query = _context19.sent;
              return _context19.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function getApplication(_x45, _x46, _x47, _x48) {
      return _ref20.apply(this, arguments);
    }

    return getApplication;
  }(),

  //
  getApplicationSource: function () {
    var _ref21 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(client, sourceId, fragments, limits) {
      var query;
      return regeneratorRuntime.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return queries.getApplicationSource(sourceId, fragments, limits);

            case 2:
              query = _context20.sent;
              return _context20.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function getApplicationSource(_x49, _x50, _x51, _x52) {
      return _ref21.apply(this, arguments);
    }

    return getApplicationSource;
  }(),

  //
  getApplicationProtections: function () {
    var _ref22 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(client, applicationId, params, fragments) {
      var query;
      return regeneratorRuntime.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return queries.getApplicationProtections(applicationId, params, fragments);

            case 2:
              query = _context21.sent;
              return _context21.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function getApplicationProtections(_x53, _x54, _x55, _x56) {
      return _ref22.apply(this, arguments);
    }

    return getApplicationProtections;
  }(),

  //
  getApplicationProtectionsCount: function () {
    var _ref23 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(client, applicationId, fragments) {
      var query;
      return regeneratorRuntime.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return queries.getApplicationProtectionsCount(applicationId, fragments);

            case 2:
              query = _context22.sent;
              return _context22.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function getApplicationProtectionsCount(_x57, _x58, _x59) {
      return _ref23.apply(this, arguments);
    }

    return getApplicationProtectionsCount;
  }(),

  //
  createTemplate: function () {
    var _ref24 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(client, template, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return mutations.createTemplate(template, fragments);

            case 2:
              mutation = _context23.sent;
              return _context23.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function createTemplate(_x60, _x61, _x62) {
      return _ref24.apply(this, arguments);
    }

    return createTemplate;
  }(),

  //
  removeTemplate: function () {
    var _ref25 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(client, id) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return mutations.removeTemplate(id);

            case 2:
              mutation = _context24.sent;
              return _context24.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function removeTemplate(_x63, _x64) {
      return _ref25.apply(this, arguments);
    }

    return removeTemplate;
  }(),

  //
  getTemplates: function () {
    var _ref26 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(client, fragments) {
      var query;
      return regeneratorRuntime.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return queries.getTemplates(fragments);

            case 2:
              query = _context25.sent;
              return _context25.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function getTemplates(_x65, _x66) {
      return _ref26.apply(this, arguments);
    }

    return getTemplates;
  }(),

  //
  getApplications: function () {
    var _ref27 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(client, fragments, params) {
      var query;
      return regeneratorRuntime.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return queries.getApplications(fragments, params);

            case 2:
              query = _context26.sent;
              return _context26.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context26.stop();
          }
        }
      }, _callee26, this);
    }));

    function getApplications(_x67, _x68, _x69) {
      return _ref27.apply(this, arguments);
    }

    return getApplications;
  }(),

  //
  addApplicationSource: function () {
    var _ref28 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(client, applicationId, applicationSource, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return mutations.addApplicationSource(applicationId, applicationSource, fragments);

            case 2:
              mutation = _context27.sent;
              return _context27.abrupt('return', this.withRetries(function () {
                return client.post('/application', mutation);
              }));

            case 4:
            case 'end':
              return _context27.stop();
          }
        }
      }, _callee27, this);
    }));

    function addApplicationSource(_x70, _x71, _x72, _x73) {
      return _ref28.apply(this, arguments);
    }

    return addApplicationSource;
  }(),

  //
  addApplicationSourceFromURL: function () {
    var _ref29 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(client, applicationId, url, fragments) {
      var file, mutation;
      return regeneratorRuntime.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return getFileFromUrl(client, url);

            case 2:
              file = _context28.sent;
              _context28.next = 5;
              return mutations.addApplicationSource(applicationId, file, fragments);

            case 5:
              mutation = _context28.sent;
              return _context28.abrupt('return', client.post('/application', mutation));

            case 7:
            case 'end':
              return _context28.stop();
          }
        }
      }, _callee28, this);
    }));

    function addApplicationSourceFromURL(_x74, _x75, _x76, _x77) {
      return _ref29.apply(this, arguments);
    }

    return addApplicationSourceFromURL;
  }(),

  //
  updateApplicationSource: function () {
    var _ref30 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee29(client, applicationSource, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return mutations.updateApplicationSource(applicationSource, fragments);

            case 2:
              mutation = _context29.sent;
              return _context29.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function updateApplicationSource(_x78, _x79, _x80) {
      return _ref30.apply(this, arguments);
    }

    return updateApplicationSource;
  }(),

  //
  removeSourceFromApplication: function () {
    var _ref31 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee30(client, sourceId, applicationId, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return mutations.removeSourceFromApplication(sourceId, applicationId, fragments);

            case 2:
              mutation = _context30.sent;
              return _context30.abrupt('return', this.withRetries(function () {
                return client.post('/application', mutation);
              }));

            case 4:
            case 'end':
              return _context30.stop();
          }
        }
      }, _callee30, this);
    }));

    function removeSourceFromApplication(_x81, _x82, _x83, _x84) {
      return _ref31.apply(this, arguments);
    }

    return removeSourceFromApplication;
  }(),

  //
  applyTemplate: function () {
    var _ref32 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee31(client, templateId, appId, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return mutations.applyTemplate(templateId, appId, fragments);

            case 2:
              mutation = _context31.sent;
              return _context31.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context31.stop();
          }
        }
      }, _callee31, this);
    }));

    function applyTemplate(_x85, _x86, _x87, _x88) {
      return _ref32.apply(this, arguments);
    }

    return applyTemplate;
  }(),

  //
  updateTemplate: function () {
    var _ref33 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee32(client, template, fragments) {
      var mutation;
      return regeneratorRuntime.wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return mutations.updateTemplate(template, fragments);

            case 2:
              mutation = _context32.sent;
              return _context32.abrupt('return', client.post('/application', mutation));

            case 4:
            case 'end':
              return _context32.stop();
          }
        }
      }, _callee32, this);
    }));

    function updateTemplate(_x89, _x90, _x91) {
      return _ref33.apply(this, arguments);
    }

    return updateTemplate;
  }(),
  getApplicationProfiling: function () {
    var _ref34 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee33(client, applicationId) {
      return regeneratorRuntime.wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              return _context33.abrupt('return', client.get('/profiling-run', { applicationId: applicationId }));

            case 1:
            case 'end':
              return _context33.stop();
          }
        }
      }, _callee33, this);
    }));

    function getApplicationProfiling(_x92, _x93) {
      return _ref34.apply(this, arguments);
    }

    return getApplicationProfiling;
  }(),
  deleteProfiling: function () {
    var _ref35 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee34(client, profilingId) {
      return regeneratorRuntime.wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              return _context34.abrupt('return', client.patch('/profiling-run/' + profilingId, {
                state: 'DELETED'
              }));

            case 1:
            case 'end':
              return _context34.stop();
          }
        }
      }, _callee34, this);
    }));

    function deleteProfiling(_x94, _x95) {
      return _ref35.apply(this, arguments);
    }

    return deleteProfiling;
  }(),

  /**
   * Starts a new instrumentation process.
   * Previous instrumentation must be deleted, before starting a new one.
   * @param client
   * @param applicationId
   * @returns {Promise<*>}
   */
  startInstrumentation: function () {
    var _ref36 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee35(client, applicationId) {
      var instrumentation;
      return regeneratorRuntime.wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              _context35.next = 2;
              return this.getApplicationProfiling(client, applicationId).catch(function (e) {
                if (e.statusCode !== 404) throw e;
              });

            case 2:
              instrumentation = _context35.sent;

              if (!instrumentation) {
                _context35.next = 6;
                break;
              }

              _context35.next = 6;
              return this.deleteProfiling(client, instrumentation.data.id);

            case 6:
              return _context35.abrupt('return', client.post('/profiling-run', { applicationId: applicationId }));

            case 7:
            case 'end':
              return _context35.stop();
          }
        }
      }, _callee35, this);
    }));

    function startInstrumentation(_x96, _x97) {
      return _ref36.apply(this, arguments);
    }

    return startInstrumentation;
  }(),

  //
  createApplicationProtection: function () {
    var _ref37 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee36(client, applicationId, protectionOptions, fragments) {
      var _ref38, args, mutation;

      return regeneratorRuntime.wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return introspection.mutation(client, 'createApplicationProtection');

            case 2:
              _ref38 = _context36.sent;
              args = _ref38.args;
              _context36.next = 6;
              return mutations.createApplicationProtection(applicationId, fragments, protectionOptions, args);

            case 6:
              mutation = _context36.sent;
              return _context36.abrupt('return', client.post('/application', mutation));

            case 8:
            case 'end':
              return _context36.stop();
          }
        }
      }, _callee36, this);
    }));

    function createApplicationProtection(_x98, _x99, _x100, _x101) {
      return _ref37.apply(this, arguments);
    }

    return createApplicationProtection;
  }(),

  /**
   * @param {object} client
   * @param {string} instrumentationId
   * @returns {Promise<object>}
   */
  getInstrumentation: function () {
    var _ref39 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee37(client, instrumentationId) {
      return regeneratorRuntime.wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              return _context37.abrupt('return', client.get('/profiling-run/' + instrumentationId));

            case 1:
            case 'end':
              return _context37.stop();
          }
        }
      }, _callee37, this);
    }));

    function getInstrumentation(_x102, _x103) {
      return _ref39.apply(this, arguments);
    }

    return getInstrumentation;
  }(),

  //
  getApplicationProtection: function () {
    var _ref40 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee38(client, applicationId, protectionId, fragments) {
      var query;
      return regeneratorRuntime.wrap(function _callee38$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              _context38.next = 2;
              return queries.getProtection(applicationId, protectionId, fragments);

            case 2:
              query = _context38.sent;
              return _context38.abrupt('return', client.get('/application', query));

            case 4:
            case 'end':
              return _context38.stop();
          }
        }
      }, _callee38, this);
    }));

    function getApplicationProtection(_x104, _x105, _x106, _x107) {
      return _ref40.apply(this, arguments);
    }

    return getApplicationProtection;
  }(),

  //
  downloadSourceMapsRequest: function () {
    var _ref41 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee39(client, protectionId) {
      return regeneratorRuntime.wrap(function _callee39$(_context39) {
        while (1) {
          switch (_context39.prev = _context39.next) {
            case 0:
              return _context39.abrupt('return', client.get('/application/sourceMaps/' + protectionId, null, false));

            case 1:
            case 'end':
              return _context39.stop();
          }
        }
      }, _callee39, this);
    }));

    function downloadSourceMapsRequest(_x108, _x109) {
      return _ref41.apply(this, arguments);
    }

    return downloadSourceMapsRequest;
  }(),
  downloadSymbolTableRequest: function () {
    var _ref42 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee40(client, protectionId) {
      return regeneratorRuntime.wrap(function _callee40$(_context40) {
        while (1) {
          switch (_context40.prev = _context40.next) {
            case 0:
              return _context40.abrupt('return', client.get('/application/symbolTable/' + protectionId, null, false));

            case 1:
            case 'end':
              return _context40.stop();
          }
        }
      }, _callee40, this);
    }));

    function downloadSymbolTableRequest(_x110, _x111) {
      return _ref42.apply(this, arguments);
    }

    return downloadSymbolTableRequest;
  }(),

  //
  downloadApplicationProtection: function () {
    var _ref43 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee41(client, protectionId) {
      return regeneratorRuntime.wrap(function _callee41$(_context41) {
        while (1) {
          switch (_context41.prev = _context41.next) {
            case 0:
              return _context41.abrupt('return', client.get('/application/download/' + protectionId, null, false));

            case 1:
            case 'end':
              return _context41.stop();
          }
        }
      }, _callee41, this);
    }));

    function downloadApplicationProtection(_x112, _x113) {
      return _ref43.apply(this, arguments);
    }

    return downloadApplicationProtection;
  }(),

  /**
   * @param {object} client
   * @param {string} instrumentationId
   * @returns {*}
   */
  downloadApplicationInstrumented: function downloadApplicationInstrumented(client, instrumentationId) {
    return client.get('/profiling-run/' + instrumentationId + '/instrumented-bundle', null, false);
  },

  /**
   * Introspect method to check if a certain field is supported.
   * @param {Object} config jscrambler client config
   * @param {String} queryOrMutation a string in ['query, 'mutation']
   * @param {String} methodName query or mutation name
   * @param {String} field args field to introspect
   * @returns {Boolean} true if the field is supported, false otherwise
   */
  introspectFieldOnMethod: function () {
    var _ref44 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee42(config, queryOrMutation, methodName, field) {
      var instrospectionType, client, result, dataArg, isFieldSupported;
      return regeneratorRuntime.wrap(function _callee42$(_context42) {
        while (1) {
          switch (_context42.prev = _context42.next) {
            case 0:
              instrospectionType = queryOrMutation.toLowerCase() === 'mutation' ? introspection.mutation : introspection.query;
              client = new this.Client(Object.assign({}, config));
              _context42.next = 4;
              return instrospectionType(client, methodName);

            case 4:
              result = _context42.sent;

              if (!(!result || !result.args)) {
                _context42.next = 8;
                break;
              }

              debug && console.log('Method *' + methodName + '* not found.');
              return _context42.abrupt('return', false);

            case 8:
              dataArg = result.args.find(function (arg) {
                return arg.name === 'data';
              });
              isFieldSupported = dataArg && dataArg.type.inputFields.some(function (e) {
                return e.name === field;
              });
              return _context42.abrupt('return', isFieldSupported);

            case 11:
            case 'end':
              return _context42.stop();
          }
        }
      }, _callee42, this);
    }));

    function introspectFieldOnMethod(_x114, _x115, _x116, _x117) {
      return _ref44.apply(this, arguments);
    }

    return introspectFieldOnMethod;
  }()
};


function getFileFromUrl(client, url) {
  return _axios2.default.get(url).then(function (res) {
    return {
      content: res.data,
      filename: _path2.default.basename(url),
      extension: _path2.default.extname(url).substr(1)
    };
  });
}